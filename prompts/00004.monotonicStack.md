invoke skill: scaffold-code-exercise

Topic: Monotonic Stack
Folder: 01-concepts/python/
Code Folder: 03-code/python/
Difficulty: Intermediate
Tags: [python, data-structures, stacks, monotonic-stack, algorithms]
Domain: python

--- CONCEPT NOTE CONTENT ---

One-liner: A monotonic stack is a stack that maintains elements 
in strictly increasing or decreasing order — used to find 
next/previous greater or smaller elements in O(n).

Mental Model:
A waiting room of indices. Every element waits in the stack 
until something arrives that resolves it. The moment a 
resolver arrives it pops everything it resolves and records 
the answer. Each element enters once and leaves once — O(n) total.

Quick Facts:
- Not a built-in — just a list used with a specific discipline
- Stack stores INDICES not values (so you can calculate distance)
- Exception: store (value, span) pairs when you need to accumulate
- Trigger words in problems: "next greater", "next smaller", 
  "how many days until", "how far can you see"
- Brute force alternative is always O(n²) nested loops
- Monotonic decreasing stack → finds next GREATER element
- Monotonic increasing stack → finds next SMALLER element
- Each element is pushed once and popped once → O(n) always

The Core Template:
stack = []
for i, val in enumerate(arr):
    while stack and val > arr[stack[-1]]:   # adjust operator per problem
        idx = stack.pop()
        # at this moment you know:
        # right boundary = i       (current element — first greater to right)
        # left boundary  = stack[-1] if stack else -1  (first greater to left)
        result[idx] = i - idx      # or whatever the problem needs
    stack.append(i)
# cleanup — anything left never found a resolver
while stack:
    idx = stack.pop()
    result[idx] = 0    # or n, or -1 depending on problem

Problems Solved and What Each Taught:
- #739 Daily Temperatures — store indices, distance = i - idx
- #901 Stock Span — store (price, span) pairs, accumulate span at pop
- #84  Largest Rectangle in Histogram — need BOTH boundaries,
       width = right - left - 1, increasing stack
- #496 Next Greater Element I — store values not indices, 
       write to dict at pop, lookup separately
- #503 Next Greater Element II — circular array, 
       loop 2*n with i%n, only push in first pass (if i < n)

Width Formula for #84 (hardest part):
At pop time you have both walls simultaneously:
  left wall  = stack[-1] after popping (first shorter bar left)
  right wall = current i (first shorter bar right)
  width = right - left - 1
If stack empty after pop → left wall is -1 → width = i

Related Links:
- [[01-concepts/python/Stacks]]
- [[04-leetcode/739-daily-temperatures]]
- [[04-leetcode/901-stock-span]]
- [[04-leetcode/84-largest-rectangle-histogram]]
- [[04-leetcode/496-next-greater-element-i]]
- [[04-leetcode/503-next-greater-element-ii]]

--- PRACTICE FILE CONTENT ---

Include the following in the .py file:

1. Next Greater Element — given [2,1,3,2,4,3] 
   return [3,3,4,4,-1,-1]
   Use basic monotonic decreasing stack storing indices.

2. Daily Temperatures #739 — [73,74,75,71,69,72,76,73]
   expected [1,1,4,2,1,1,0,0]

3. Largest Rectangle #84 — [2,1,5,6,2,3]
   expected 10
   Include the two-boundary width formula with clear comments.

4. Next Greater Element I #496 — 
   nums1=[4,1,2] nums2=[1,3,4,2] expected [-1,3,-1]
   Build dict at pop time, lookup nums1 separately.

5. Next Greater Element II #503 — 
   [1,2,1] expected [2,-1,2]
   Loop 2*n, push only if i < n.

Include assert-based tests for all 5.
Add a comment block at the top explaining the core template
and when to use monotonic stack vs brute force.
Link back to: [[01-concepts/python/Monotonic Stack]]


Code solutions can be also found in 
C:\DataMajor\vault\00-temp
C:\DataMajor\playground\LEC\Monotonic_Stack

Please while creating artifacts look at the files at these path to create a complete artifacts
