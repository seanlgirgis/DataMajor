<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>LRU CACHE / MEMOIZATION — Syntax Card</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body {
    font-family: "Courier New", Courier, monospace;
    font-size: 11px; line-height: 1.5; color: #111;
    background: #fff; padding: 18px 22px;
  }
  h1 { font-size: 15px; font-weight: bold; letter-spacing: 2px;
       border-bottom: 2px solid #111; padding-bottom: 4px;
       margin-bottom: 10px; text-transform: uppercase; }
  h2 { font-size: 10px; font-weight: bold; letter-spacing: 1px;
       text-transform: uppercase; color: #555;
       margin: 10px 0 3px 0; border-bottom: 1px solid #ccc; }
  pre { background: #f4f4f4; padding: 5px 8px; border-left: 3px solid #333;
        white-space: pre; font-size: 10.5px; line-height: 1.6; }
  .comment { color: #555; }
  .warn    { color: #c00; }
  .good    { color: #060; }
  .cols { display: grid; grid-template-columns: 1fr 1fr; gap: 0 16px; }
  @media print { body { padding: 10px 14px; } @page { margin: 0.4in; size: letter; } }
</style>
</head>
<body>
<h1>LRU CACHE / MEMOIZATION — Python Syntax Card</h1>
<div class="cols">
<div>

<h2>Basic Usage</h2>
<pre>from functools import lru_cache

@lru_cache(maxsize=None)        <span class="comment"># None = unlimited</span>
def fib(n):
    if n <= 1: return n
    return fib(n-1) + fib(n-2) <span class="comment"># cache hit on repeat</span></pre>

<h2>cache — Python 3.9+ shorthand</h2>
<pre>from functools import cache     <span class="comment"># = lru_cache(maxsize=None)</span>

@cache
def solve(n):
    ...</pre>

<h2>On a Class Method</h2>
<pre>class Solution:
    @lru_cache(maxsize=None)
    def climbStairs(self, n: int) -> int:
        if n <= 2: return n
        return self.climbStairs(n-1) + self.climbStairs(n-2)
<span class="warn"># WARNING: self is part of cache key — memory leak risk</span>
<span class="comment"># Safe for interviews, not production</span></pre>

<h2>Cache Info / Clear</h2>
<pre>fib.cache_info()    <span class="comment"># hits, misses, maxsize, currsize</span>
fib.cache_clear()   <span class="comment"># wipe the cache</span></pre>

<h2>Complexity Impact</h2>
<pre><span class="warn"># Without cache:  O(2^n) — recomputes everything</span>
<span class="good"># With cache:     O(n)   — each input computed once</span>
<span class="comment"># Space:          O(n)   — cache + call stack</span></pre>

</div>
<div>

<h2>Manual memo={} — Interview Trick</h2>
<pre><span class="comment"># memo={} created ONCE at definition — persists</span>
def solve(n, memo={}):
    if n in memo: return memo[n]
    if n <= 2: return n
    memo[n] = solve(n-1, memo) + solve(n-2, memo)
    return memo[n]</pre>

<h2>Safer Manual Memo</h2>
<pre><span class="comment"># Explicit None check — no mutable default risk</span>
def solve(n, memo=None):
    if memo is None: memo = {}
    if n in memo: return memo[n]
    memo[n] = solve(n-1, memo) + solve(n-2, memo)
    return memo[n]</pre>

<h2>Hashability — Args Must Be Hashable</h2>
<pre><span class="warn">@lru_cache
def bad(nums: list): ...    # TypeError — list not hashable</span>

<span class="good">@lru_cache
def good(nums: tuple): ...  # tuple OK — hashable</span>

<span class="comment"># Convert list to tuple before calling:</span>
good(tuple(my_list))</pre>

<h2>When to Reach for @lru_cache</h2>
<pre><span class="comment"># Pure function (same input = same output)</span>
<span class="comment"># Subproblems repeat (DP, Fibonacci, grid paths)</span>
<span class="comment"># Args are hashable (int, str, tuple)</span>

<span class="comment"># DP decision checklist:</span>
<span class="comment"># 1. Can I define subproblems?</span>
<span class="comment"># 2. Do subproblems overlap?  → cache</span>
<span class="comment"># 3. Can I go bottom-up?      → O(1) space</span></pre>

</div>
</div>
</body>
</html>
