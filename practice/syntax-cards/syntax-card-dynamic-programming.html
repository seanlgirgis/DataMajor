<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>DYNAMIC PROGRAMMING — Syntax Card</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body { font-family: "Courier New", Courier, monospace; font-size: 11px; line-height: 1.5; color: #111; background: #fff; padding: 18px 22px; }
  h1 { font-size: 15px; font-weight: bold; letter-spacing: 2px; border-bottom: 2px solid #111; padding-bottom: 4px; margin-bottom: 10px; text-transform: uppercase; }
  h2 { font-size: 10px; font-weight: bold; letter-spacing: 1px; text-transform: uppercase; color: #555; margin: 10px 0 3px 0; border-bottom: 1px solid #ccc; }
  pre { background: #f4f4f4; padding: 5px 8px; border-left: 3px solid #333; white-space: pre; font-size: 10.5px; line-height: 1.6; }
  .comment { color: #555; } .warn { color: #c00; } .good { color: #060; }
  .cols { display: grid; grid-template-columns: 1fr 1fr; gap: 0 16px; }
  @media print { body { padding: 10px 14px; } @page { margin: 0.4in; size: letter; } }
</style>
</head>
<body>
<h1>DYNAMIC PROGRAMMING — Python Syntax Card</h1>
<div class="cols">
<div>

<h2>Decision Framework</h2>
<pre><span class="comment"># 1. Define subproblems</span>
<span class="comment"># 2. Overlapping subproblems? -> cache</span>
<span class="comment"># 3. Bottom-up possible?     -> O(1) space</span></pre>

<h2>Climbing Stairs / Fibonacci — O(1) space</h2>
<pre>a, b = 1, 1
for _ in range(n - 1):
    a, b = b, a + b
return b</pre>

<h2>House Robber — skip-one constraint</h2>
<pre>prev2 = prev1 = 0
for n in nums:
    curr  = max(prev1, n + prev2)  <span class="comment"># skip or rob</span>
    prev2, prev1 = prev1, curr
return prev1</pre>

<h2>Maximum Subarray — Kadane's</h2>
<pre>max_sum = curr = nums[0]
for n in nums[1:]:
    curr    = max(n, curr + n)     <span class="comment"># restart or extend</span>
    max_sum = max(max_sum, curr)
return max_sum
<span class="warn"># init max_sum = nums[0], NOT 0 (handles all-negatives)</span></pre>

</div>
<div>

<h2>Best Time Buy/Sell — running min</h2>
<pre>min_p = float('inf'); profit = 0
for p in prices:
    profit = max(profit, p - min_p)
    min_p  = min(min_p, p)
return profit
<span class="comment"># check profit BEFORE updating min_p</span></pre>

<h2>@cache — top-down memoization</h2>
<pre>from functools import cache

@cache
def dp(i):
    if i &lt;= 1: return i
    return dp(i-1) + dp(i-2)
<span class="warn"># args must be hashable (int, str, tuple — not list)</span></pre>

<h2>In-Place DP Table</h2>
<pre>for i in range(1, len(nums)):
    if i == 1:
        nums[1] = max(nums[0], nums[1])
    else:
        nums[i] = max(nums[i] + nums[i-2],
                      nums[i-1])
return nums[-1]</pre>

<h2>Pattern Map</h2>
<pre><span class="good"># No-skip sequence  -> Kadane / running value</span>
<span class="good"># Skip-one          -> House Robber (prev2/prev1)</span>
<span class="good"># Count ways        -> Fibonacci / bottom-up</span>
<span class="comment"># 2D grid paths -> dp[i][j]=dp[i-1][j]+dp[i][j-1]</span></pre>

</div>
</div>
</body>
</html>
