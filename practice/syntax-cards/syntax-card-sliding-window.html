<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>SLIDING WINDOW — Syntax Card</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body { font-family: "Courier New", Courier, monospace; font-size: 11px; line-height: 1.5; color: #111; background: #fff; padding: 18px 22px; }
  h1 { font-size: 15px; font-weight: bold; letter-spacing: 2px; border-bottom: 2px solid #111; padding-bottom: 4px; margin-bottom: 10px; text-transform: uppercase; }
  h2 { font-size: 10px; font-weight: bold; letter-spacing: 1px; text-transform: uppercase; color: #555; margin: 10px 0 3px 0; border-bottom: 1px solid #ccc; }
  pre { background: #f4f4f4; padding: 5px 8px; border-left: 3px solid #333; white-space: pre; font-size: 10.5px; line-height: 1.6; }
  .comment { color: #555; } .warn { color: #c00; } .good { color: #060; }
  .cols { display: grid; grid-template-columns: 1fr 1fr; gap: 0 16px; }
  @media print { body { padding: 10px 14px; } @page { margin: 0.4in; size: letter; } }
</style>
</head>
<body>
<h1>SLIDING WINDOW — Python Syntax Card</h1>
<div class="cols">
<div>

<h2>Fixed-Size Window</h2>
<pre>window_sum = sum(nums[:k])
for i in range(k, len(nums)):
    window_sum += nums[i] - nums[i - k]  <span class="comment"># slide</span>
    result.append(window_sum)</pre>

<h2>Variable Window — longest valid</h2>
<pre>l = 0; window = {}; best = 0
for r, ch in enumerate(s):
    window[ch] = window.get(ch, 0) + 1
    while not_valid(window):   <span class="comment"># shrink left</span>
        window[s[l]] -= 1
        if window[s[l]] == 0: del window[s[l]]
        l += 1
    best = max(best, r - l + 1)</pre>

<h2>Longest Substr No Repeat (LC 0003)</h2>
<pre>l = 0; seen = {}; best = 0
for r, ch in enumerate(s):
    if ch in seen and seen[ch] &gt;= l:
        l = seen[ch] + 1     <span class="comment"># jump past duplicate</span>
    seen[ch] = r
    best = max(best, r - l + 1)</pre>

</div>
<div>

<h2>Minimum Window Substring</h2>
<pre>need = Counter(t); have = 0; total = len(need)
l = 0; result = ""
for r, ch in enumerate(s):
    if ch in need:
        need[ch] -= 1
        if need[ch] == 0: have += 1
    while have == total:       <span class="comment"># valid — shrink</span>
        if not result or r-l+1 &lt; len(result):
            result = s[l:r+1]
        if s[l] in need:
            need[s[l]] += 1
            if need[s[l]] &gt; 0: have -= 1
        l += 1</pre>

<h2>Key Formulas</h2>
<pre>window_size  = r - l + 1
drop_element = nums[i - k]   <span class="comment"># fixed window</span>
<span class="comment"># expand: r moves right every iteration</span>
<span class="comment"># shrink: l moves right inside while loop</span></pre>

<h2>When to Use</h2>
<pre><span class="good"># Contiguous subarray / substring</span>
<span class="good"># "longest / shortest / max / min" window</span>
<span class="comment"># O(n) — each element enters/leaves once</span>
<span class="warn"># NOT for non-contiguous subsequences</span></pre>

</div>
</div>
</body>
</html>
